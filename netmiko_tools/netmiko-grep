#!/usr/bin/env python
"""
Create grep like remote behavior on show run or command output

ToDo:
2. No support for grep options
3. Unit tests
4. Test on larger set of devices >50
5. Write to ~/.netmiko directory
6. Look for .netmiko.cfg in local dir then ~
7. Remove files (what about cache)
8. Test on windows
9. Test username/password arguments
"""

from __future__ import print_function
from __future__ import unicode_literals

import argparse
import sys
import io
import os.path
import subprocess
import threading
from Queue import Queue
from datetime import datetime

from netmiko import ConnectHandler
from pprint import pprint

GREP = '/bin/grep'

# Dictionary mapping 'show run' for vendors with different command
SHOW_RUN_MAPPER = {
    'juniper': 'show configuration',
    'juniper_junos': 'show configuration',
}


def grepx(files, pattern, grep_options, use_colors=True):
    """Call system grep"""
    if not isinstance(files, (list, tuple)):
        files = [files]
    if use_colors:
        grep_options += ['--color=auto']
    grep_list = [GREP] + grep_options + [pattern] + files
    proc = subprocess.Popen(grep_list, shell=False)
    proc.communicate()
    return ''


def load_devices():
    """Find and load .netmiko.cfg YAML file."""
    yaml_devices_file = find_file()
    return load_yaml_file(yaml_devices_file)


def find_file(file_name=None):
    """Look for .netmiko.cfg in current dir, then ~/.netmiko.cfg."""
    check_files = [
        '.netmiko.cfg',
        os.path.expanduser('~') + '/.netmiko.cfg',
    ]
    if file_name:
        check_files.insert(0, file_name)
    for test_file in check_files:
        if os.path.isfile(test_file):
            return test_file
    raise IOError("{} file not found in current dir or home dir.".format(file_name))


def load_yaml_file(yaml_file):
    """Read YAML file."""
    try:
        import yaml
    except ImportError:
        sys.exit("Unable to import yaml module.")
    try:
        with io.open(yaml_file, encoding='utf-8') as fname:
            return yaml.load(fname)
    except IOError:
        sys.exit("Unable to open YAML file: {0}".format(yaml_file))


def obtain_file_name(device_name):
    """Create file name based on device_name."""
    return "/tmp/{0}.txt".format(device_name)


def write_tmp_file(device_name, output):
    file_name = obtain_file_name(device_name)
    with open(file_name, "w") as f:
        f.write(output)
    return file_name


def ssh_conn(device_name, a_device, cli_command, output_q):
    net_connect = ConnectHandler(**a_device)
    net_connect.enable()
    output = net_connect.send_command_expect(cli_command)
    output_q.put({device_name: output})


def obtain_all_devices(my_devices):
    """Dynamically create 'all' group."""
    new_devices = {}
    for device_name, device_or_group in my_devices.items():
        # Skip any groups
        if not isinstance(device_or_group, list):
            new_devices[device_name] = device_or_group
    return new_devices


def display_inventory(my_devices):
    """Print out inventory devices and groups."""
    inventory_groups = ['all']
    inventory_devices = []
    for k, v in my_devices.items():
        if isinstance(v, list):
            inventory_groups.append(k)
        elif isinstance(v, dict):
            inventory_devices.append((k, v['device_type']))

    inventory_groups.sort()
    inventory_devices.sort(key=lambda x: x[0])
    print("\nDevices:")
    print('-' * 40)
    for a_device, device_type in inventory_devices:
        device_type = "  ({})".format(device_type)
        print("{:<25}{:>15}".format(a_device, device_type))
    print("\n\nGroups:")
    print('-' * 40)
    for a_group in inventory_groups:
        print(a_group)
    print()


def parse_arguments(args):
    """Parse command-line arguments."""
    parser = argparse.ArgumentParser(description="Grep pattern search on Netmiko output")
    arg_pattern = parser.add_argument("pattern", nargs='?', help="Pattern to search for",
                                      action="store", type=str)
    arg_devices = parser.add_argument("devices", nargs='?', help="Device or group to connect to",
                                      action="store", type=str)
    parser.add_argument("--cmd", help="Remote command to execute",
                        action="store", default=None, type=str)
    parser.add_argument("--username", help="Username", action="store", type=str)
    parser.add_argument("--password", help="Password", action="store", type=str)
    parser.add_argument("--use_cache", help="Use cached files", action="store_true")
    parser.add_argument("--list-devices", help="List devices from inventory", action="store_true")
    cli_args = parser.parse_args(args)
    if not cli_args.list_devices:
        if not cli_args.devices or not cli_args.pattern:
            parser.error('Grep pattern or devices not specified.')
    return cli_args


def main(args):
    start_time = datetime.now()
    cli_args = parse_arguments(args)

    list_devices = cli_args.list_devices
    if list_devices:
        my_devices = load_devices()
        display_inventory(my_devices)
        return 0

    cli_command = cli_args.cmd
    cmd_arg = False
    if cli_command:
        cmd_arg = True
    device_or_group = cli_args.devices.strip()
    pattern = cli_args.pattern
    use_cached_files = cli_args.use_cache

    output_q = Queue()
    my_devices = load_devices()
    if device_or_group == 'all':
        device_group = obtain_all_devices(my_devices)
    else:
        try:
            devicedict_or_group = my_devices[device_or_group]
            device_group = {}
            if isinstance(devicedict_or_group, list):
                for tmp_device_name in devicedict_or_group:
                    device_group[tmp_device_name] = my_devices[tmp_device_name]
            else:
                device_group[device_or_group] = devicedict_or_group
        except KeyError:
            sys.exit("Error reading from .netmiko.cfg file."
                     " Device or group not found: {0}".format(device_or_group))

    # Retrieve output from devices
    my_files = []
    if not use_cached_files:
        for device_name, a_device in device_group.items():
            if not cmd_arg:
                cli_command = SHOW_RUN_MAPPER.get(a_device['device_type'], 'show run')
            my_thread = threading.Thread(target=ssh_conn, args=(device_name, a_device,
                                                                cli_command, output_q))
            my_thread.start()

        # Make sure all threads have finished
        main_thread = threading.currentThread()
        for some_thread in threading.enumerate():
            if some_thread != main_thread:
                some_thread.join()

        # Write files
        while not output_q.empty():
            my_dict = output_q.get()
            for device_name, output in my_dict.iteritems():
                file_name = write_tmp_file(device_name, output)
                my_files.append(file_name)

    else:
        for device_name in device_group:
            file_name = obtain_file_name(device_name)
            my_files.append(file_name)

    grep_options = []
    grepx(my_files, pattern, grep_options)
    print("Total time: {0}".format(datetime.now() - start_time))
    return 0

if __name__ == "__main__":
    sys.exit(main(sys.argv[1:]))
